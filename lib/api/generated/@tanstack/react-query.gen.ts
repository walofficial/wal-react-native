// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  getLocationFeeds,
  sendPushNotificationFeedsNotificationsPushPost,
  getLiveUsers,
  countLiveUsers,
  getSingleFeed,
  checkLocation,
  goLive,
  publishPost,
  getCountryFeed,
  getScreenshot,
  generateSocialMediaContentFeedsGenerateSocialMediaContentGet,
  sendUserNotificationFeedsSendUserNotificationPost,
  uploadUserPhotos,
  uploadPhotoToLocationVerifyPhotosUploadToLocationPost,
  submitUserVideoVerificationLocationUpload,
  executeUserVideoVerificationLocationUpload,
  liveWebhook,
  getLiveStreamToken,
  startLive,
  stopLive,
  createUser,
  getUser,
  updateVerificationVisibility,
  getVerifications,
  getUserVerification,
  updateUser,
  upsertFcm,
  getFcmToken,
  deleteFcm,
  getUserLocation,
  deleteUser,
  checkRegisteredUsers,
  blockUserBlockTargetIdPost,
  unblockUserUnblockTargetIdPost,
  reportUserReportTargetIdPost,
  checkUsernameUserCheckUsernameUsernameGet,
  getUserProfileUserProfileUserIdGet,
  getUserProfileByUsername,
  getLocationFeedPaginated,
  sendFriendRequest,
  getFriendRequests,
  acceptFriendRequest,
  rejectFriendRequest,
  getFriendsList,
  removeFriend,
  getBlockedFriends,
  updateMessageStateChatUpdateMessagesPost,
  getMessagesChatMessagesGet,
  getUserChatRooms,
  createChatRoom,
  expireChatRoomChatExpireChatRoomPost,
  sendPublicKeyChatSendPublicKeyPost,
  getMessageChatRoom,
  getNotifications,
  markNotificationsRead,
  getUnreadCount,
  pokeUserLiveActionsPokeTargetUserIdPost,
  messageUserLiveActionsMessageTargetUserIdPost,
  likeVerification,
  unlikeVerification,
  getVerificationLikesCount,
  trackImpressions,
  getImpressionsCount,
  rateFactCheck,
  unrateFactCheck,
  getFactCheckRatingsCount,
  getFactCheck,
  getRoomPreviewData,
  stopStream,
  createStream,
  createSpace,
  inviteToStage,
  removeFromStage,
  raiseHand,
  subscribeSpace,
  triggerSpaceStart,
  createCommentCommentsPost,
  getVerificationComments,
  unlikeComment,
  likeComment,
  getVerificationCommentsCount,
  deleteComment,
  removeReaction,
  getCommentReactionsCommentsCommentIdReactionsGet,
  addOrUpdateReactionCommentsCommentIdReactionsPost,
  getCountry,
  endpointHealthGet,
} from '../sdk.gen';
import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData,
  type DefaultError,
} from '@tanstack/react-query';
import type {
  GetLocationFeedsData,
  SendPushNotificationFeedsNotificationsPushPostData,
  SendPushNotificationFeedsNotificationsPushPostError,
  GetLiveUsersData,
  CountLiveUsersData,
  GetSingleFeedData,
  CheckLocationData,
  GoLiveData,
  GoLiveError,
  GoLiveResponse,
  PublishPostData,
  PublishPostError,
  PublishPostResponse,
  GetCountryFeedData,
  GetScreenshotData,
  GenerateSocialMediaContentFeedsGenerateSocialMediaContentGetData,
  SendUserNotificationFeedsSendUserNotificationPostData,
  SendUserNotificationFeedsSendUserNotificationPostError,
  UploadUserPhotosData,
  UploadUserPhotosError,
  UploadUserPhotosResponse,
  UploadPhotoToLocationVerifyPhotosUploadToLocationPostData,
  UploadPhotoToLocationVerifyPhotosUploadToLocationPostError,
  UploadPhotoToLocationVerifyPhotosUploadToLocationPostResponse,
  SubmitUserVideoVerificationLocationUploadData,
  SubmitUserVideoVerificationLocationUploadError,
  SubmitUserVideoVerificationLocationUploadResponse,
  ExecuteUserVideoVerificationLocationUploadData,
  ExecuteUserVideoVerificationLocationUploadError,
  LiveWebhookData,
  LiveWebhookError,
  LiveWebhookResponse,
  GetLiveStreamTokenData,
  StartLiveData,
  StartLiveError,
  StartLiveResponse2,
  StopLiveData,
  StopLiveError,
  CreateUserData,
  CreateUserError,
  CreateUserResponse,
  GetUserData,
  UpdateVerificationVisibilityData,
  UpdateVerificationVisibilityError,
  UpdateVerificationVisibilityResponse,
  GetVerificationsData,
  GetVerificationsError,
  GetVerificationsResponse,
  GetUserVerificationData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  UpsertFcmData,
  UpsertFcmResponse,
  GetFcmTokenData,
  DeleteFcmData,
  DeleteFcmResponse,
  GetUserLocationData,
  GetUserLocationError,
  GetUserLocationResponse,
  DeleteUserData,
  DeleteUserResponse,
  CheckRegisteredUsersData,
  CheckRegisteredUsersError,
  CheckRegisteredUsersResponse,
  BlockUserBlockTargetIdPostData,
  BlockUserBlockTargetIdPostError,
  UnblockUserUnblockTargetIdPostData,
  UnblockUserUnblockTargetIdPostError,
  ReportUserReportTargetIdPostData,
  ReportUserReportTargetIdPostError,
  ReportUserReportTargetIdPostResponse,
  CheckUsernameUserCheckUsernameUsernameGetData,
  GetUserProfileUserProfileUserIdGetData,
  GetUserProfileByUsernameData,
  GetLocationFeedPaginatedData,
  GetLocationFeedPaginatedError,
  GetLocationFeedPaginatedResponse,
  SendFriendRequestData,
  SendFriendRequestError,
  SendFriendRequestResponse,
  GetFriendRequestsData,
  AcceptFriendRequestData,
  AcceptFriendRequestError,
  RejectFriendRequestData,
  RejectFriendRequestError,
  GetFriendsListData,
  GetFriendsListError,
  GetFriendsListResponse,
  RemoveFriendData,
  RemoveFriendError,
  GetBlockedFriendsData,
  UpdateMessageStateChatUpdateMessagesPostData,
  UpdateMessageStateChatUpdateMessagesPostError,
  UpdateMessageStateChatUpdateMessagesPostResponse,
  GetMessagesChatMessagesGetData,
  GetMessagesChatMessagesGetError,
  GetMessagesChatMessagesGetResponse,
  GetUserChatRoomsData,
  CreateChatRoomData,
  CreateChatRoomError,
  CreateChatRoomResponse2,
  ExpireChatRoomChatExpireChatRoomPostData,
  ExpireChatRoomChatExpireChatRoomPostError,
  SendPublicKeyChatSendPublicKeyPostData,
  SendPublicKeyChatSendPublicKeyPostError,
  GetMessageChatRoomData,
  GetNotificationsData,
  GetNotificationsError,
  GetNotificationsResponse,
  MarkNotificationsReadData,
  MarkNotificationsReadResponse2,
  GetUnreadCountData,
  PokeUserLiveActionsPokeTargetUserIdPostData,
  PokeUserLiveActionsPokeTargetUserIdPostError,
  MessageUserLiveActionsMessageTargetUserIdPostData,
  MessageUserLiveActionsMessageTargetUserIdPostError,
  LikeVerificationData,
  LikeVerificationError,
  LikeVerificationResponse2,
  UnlikeVerificationData,
  UnlikeVerificationError,
  UnlikeVerificationResponse2,
  GetVerificationLikesCountData,
  TrackImpressionsData,
  TrackImpressionsError,
  TrackImpressionsResponse2,
  GetImpressionsCountData,
  RateFactCheckData,
  RateFactCheckError,
  RateFactCheckResponse2,
  UnrateFactCheckData,
  UnrateFactCheckError,
  UnrateFactCheckResponse2,
  GetFactCheckRatingsCountData,
  GetFactCheckData,
  GetRoomPreviewDataData,
  StopStreamData,
  StopStreamError,
  CreateStreamData,
  CreateStreamError,
  CreateSpaceData,
  CreateSpaceError,
  CreateSpaceResponse2,
  InviteToStageData,
  InviteToStageError,
  RemoveFromStageData,
  RemoveFromStageError,
  RaiseHandData,
  RaiseHandError,
  SubscribeSpaceData,
  SubscribeSpaceError,
  TriggerSpaceStartData,
  TriggerSpaceStartError,
  CreateCommentCommentsPostData,
  CreateCommentCommentsPostError,
  GetVerificationCommentsData,
  GetVerificationCommentsError,
  GetVerificationCommentsResponse2,
  UnlikeCommentData,
  UnlikeCommentError,
  UnlikeCommentResponse,
  LikeCommentData,
  LikeCommentError,
  LikeCommentResponse2,
  GetVerificationCommentsCountData,
  DeleteCommentData,
  DeleteCommentError,
  RemoveReactionData,
  RemoveReactionError,
  RemoveReactionResponse2,
  GetCommentReactionsCommentsCommentIdReactionsGetData,
  AddOrUpdateReactionCommentsCommentIdReactionsPostData,
  AddOrUpdateReactionCommentsCommentIdReactionsPostError,
  GetCountryData,
  EndpointHealthGetData,
} from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL:
      options?.baseURL ||
      (options?.client ?? _heyApiClient).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getLocationFeedsQueryKey = (
  options: Options<GetLocationFeedsData>,
) => createQueryKey('getLocationFeeds', options);

/**
 * Get Location Feeds
 */
export const getLocationFeedsOptions = (
  options: Options<GetLocationFeedsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLocationFeeds({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLocationFeedsQueryKey(options),
  });
};

export const sendPushNotificationFeedsNotificationsPushPostQueryKey = (
  options: Options<SendPushNotificationFeedsNotificationsPushPostData>,
) => createQueryKey('sendPushNotificationFeedsNotificationsPushPost', options);

/**
 * Send Push Notification
 */
export const sendPushNotificationFeedsNotificationsPushPostOptions = (
  options: Options<SendPushNotificationFeedsNotificationsPushPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sendPushNotificationFeedsNotificationsPushPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: sendPushNotificationFeedsNotificationsPushPostQueryKey(options),
  });
};

/**
 * Send Push Notification
 */
export const sendPushNotificationFeedsNotificationsPushPostMutation = (
  options?: Partial<
    Options<SendPushNotificationFeedsNotificationsPushPostData>
  >,
): UseMutationOptions<
  unknown,
  AxiosError<SendPushNotificationFeedsNotificationsPushPostError>,
  Options<SendPushNotificationFeedsNotificationsPushPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<SendPushNotificationFeedsNotificationsPushPostError>,
    Options<SendPushNotificationFeedsNotificationsPushPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await sendPushNotificationFeedsNotificationsPushPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLiveUsersQueryKey = (options: Options<GetLiveUsersData>) =>
  createQueryKey('getLiveUsers', options);

/**
 * Live Users
 */
export const getLiveUsersOptions = (options: Options<GetLiveUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLiveUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLiveUsersQueryKey(options),
  });
};

export const countLiveUsersQueryKey = (options: Options<CountLiveUsersData>) =>
  createQueryKey('countLiveUsers', options);

/**
 * Count Live Users
 */
export const countLiveUsersOptions = (options: Options<CountLiveUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await countLiveUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: countLiveUsersQueryKey(options),
  });
};

export const getSingleFeedQueryKey = (options: Options<GetSingleFeedData>) =>
  createQueryKey('getSingleFeed', options);

/**
 * Get Single Feed
 */
export const getSingleFeedOptions = (options: Options<GetSingleFeedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSingleFeed({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSingleFeedQueryKey(options),
  });
};

export const checkLocationQueryKey = (options: Options<CheckLocationData>) =>
  createQueryKey('checkLocation', options);

/**
 * Check Location
 */
export const checkLocationOptions = (options: Options<CheckLocationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkLocation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkLocationQueryKey(options),
  });
};

export const goLiveQueryKey = (options: Options<GoLiveData>) =>
  createQueryKey('goLive', options);

/**
 * Go Live
 */
export const goLiveOptions = (options: Options<GoLiveData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await goLive({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: goLiveQueryKey(options),
  });
};

/**
 * Go Live
 */
export const goLiveMutation = (
  options?: Partial<Options<GoLiveData>>,
): UseMutationOptions<
  GoLiveResponse,
  AxiosError<GoLiveError>,
  Options<GoLiveData>
> => {
  const mutationOptions: UseMutationOptions<
    GoLiveResponse,
    AxiosError<GoLiveError>,
    Options<GoLiveData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await goLive({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const publishPostQueryKey = (options: Options<PublishPostData>) =>
  createQueryKey('publishPost', options);

/**
 * Publish Post
 */
export const publishPostOptions = (options: Options<PublishPostData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await publishPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: publishPostQueryKey(options),
  });
};

/**
 * Publish Post
 */
export const publishPostMutation = (
  options?: Partial<Options<PublishPostData>>,
): UseMutationOptions<
  PublishPostResponse,
  AxiosError<PublishPostError>,
  Options<PublishPostData>
> => {
  const mutationOptions: UseMutationOptions<
    PublishPostResponse,
    AxiosError<PublishPostError>,
    Options<PublishPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await publishPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCountryFeedQueryKey = (options?: Options<GetCountryFeedData>) =>
  createQueryKey('getCountryFeed', options);

/**
 * Get Country Feed
 */
export const getCountryFeedOptions = (
  options?: Options<GetCountryFeedData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCountryFeed({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCountryFeedQueryKey(options),
  });
};

export const getScreenshotQueryKey = (options: Options<GetScreenshotData>) =>
  createQueryKey('getScreenshot', options);

/**
 * Get Screenshot
 * Generate and cache a screenshot for a verification ID.
 * Returns cached version if available, otherwise generates new screenshot.
 *
 * Args:
 * verification_id: The verification ID to generate screenshot for
 * tab: Content perspective (neutral, government, opposition)
 *
 * Returns:
 * Raw bytes of the screenshot image as JPEG format
 */
export const getScreenshotOptions = (options: Options<GetScreenshotData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getScreenshot({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getScreenshotQueryKey(options),
  });
};

export const generateSocialMediaContentFeedsGenerateSocialMediaContentGetQueryKey =
  (
    options?: Options<GenerateSocialMediaContentFeedsGenerateSocialMediaContentGetData>,
  ) =>
    createQueryKey(
      'generateSocialMediaContentFeedsGenerateSocialMediaContentGet',
      options,
    );

/**
 * Generate Social Media Content
 * Generate social media content by selecting an appropriate news article or fact check,
 * generating title/description, and creating a screenshot.
 *
 * Args:
 * tab: Content perspective (neutral, government, opposition)
 * include_fact_checks: Whether to include fact-checked content (is_generated_news=False)
 *
 * Returns:
 * Dictionary containing image_url, title, description, and verification_id
 */
export const generateSocialMediaContentFeedsGenerateSocialMediaContentGetOptions =
  (
    options?: Options<GenerateSocialMediaContentFeedsGenerateSocialMediaContentGetData>,
  ) => {
    return queryOptions({
      queryFn: async ({ queryKey, signal }) => {
        const { data } =
          await generateSocialMediaContentFeedsGenerateSocialMediaContentGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true,
          });
        return data;
      },
      queryKey:
        generateSocialMediaContentFeedsGenerateSocialMediaContentGetQueryKey(
          options,
        ),
    });
  };

export const sendUserNotificationFeedsSendUserNotificationPostQueryKey = (
  options: Options<SendUserNotificationFeedsSendUserNotificationPostData>,
) =>
  createQueryKey('sendUserNotificationFeedsSendUserNotificationPost', options);

/**
 * Send User Notification
 * Send notification to a specific user
 * This endpoint is called by Google Cloud Tasks
 */
export const sendUserNotificationFeedsSendUserNotificationPostOptions = (
  options: Options<SendUserNotificationFeedsSendUserNotificationPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sendUserNotificationFeedsSendUserNotificationPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey:
      sendUserNotificationFeedsSendUserNotificationPostQueryKey(options),
  });
};

/**
 * Send User Notification
 * Send notification to a specific user
 * This endpoint is called by Google Cloud Tasks
 */
export const sendUserNotificationFeedsSendUserNotificationPostMutation = (
  options?: Partial<
    Options<SendUserNotificationFeedsSendUserNotificationPostData>
  >,
): UseMutationOptions<
  unknown,
  AxiosError<SendUserNotificationFeedsSendUserNotificationPostError>,
  Options<SendUserNotificationFeedsSendUserNotificationPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<SendUserNotificationFeedsSendUserNotificationPostError>,
    Options<SendUserNotificationFeedsSendUserNotificationPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await sendUserNotificationFeedsSendUserNotificationPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadUserPhotosQueryKey = (
  options: Options<UploadUserPhotosData>,
) => createQueryKey('uploadUserPhotos', options);

/**
 * Upload Photos
 */
export const uploadUserPhotosOptions = (
  options: Options<UploadUserPhotosData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadUserPhotos({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadUserPhotosQueryKey(options),
  });
};

/**
 * Upload Photos
 */
export const uploadUserPhotosMutation = (
  options?: Partial<Options<UploadUserPhotosData>>,
): UseMutationOptions<
  UploadUserPhotosResponse,
  AxiosError<UploadUserPhotosError>,
  Options<UploadUserPhotosData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadUserPhotosResponse,
    AxiosError<UploadUserPhotosError>,
    Options<UploadUserPhotosData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await uploadUserPhotos({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadPhotoToLocationVerifyPhotosUploadToLocationPostQueryKey = (
  options: Options<UploadPhotoToLocationVerifyPhotosUploadToLocationPostData>,
) =>
  createQueryKey(
    'uploadPhotoToLocationVerifyPhotosUploadToLocationPost',
    options,
  );

/**
 * Upload Photo To Location
 */
export const uploadPhotoToLocationVerifyPhotosUploadToLocationPostOptions = (
  options: Options<UploadPhotoToLocationVerifyPhotosUploadToLocationPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } =
        await uploadPhotoToLocationVerifyPhotosUploadToLocationPost({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
      return data;
    },
    queryKey:
      uploadPhotoToLocationVerifyPhotosUploadToLocationPostQueryKey(options),
  });
};

/**
 * Upload Photo To Location
 */
export const uploadPhotoToLocationVerifyPhotosUploadToLocationPostMutation = (
  options?: Partial<
    Options<UploadPhotoToLocationVerifyPhotosUploadToLocationPostData>
  >,
): UseMutationOptions<
  UploadPhotoToLocationVerifyPhotosUploadToLocationPostResponse,
  AxiosError<UploadPhotoToLocationVerifyPhotosUploadToLocationPostError>,
  Options<UploadPhotoToLocationVerifyPhotosUploadToLocationPostData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadPhotoToLocationVerifyPhotosUploadToLocationPostResponse,
    AxiosError<UploadPhotoToLocationVerifyPhotosUploadToLocationPostError>,
    Options<UploadPhotoToLocationVerifyPhotosUploadToLocationPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } =
        await uploadPhotoToLocationVerifyPhotosUploadToLocationPost({
          ...options,
          ...localOptions,
          throwOnError: true,
        });
      return data;
    },
  };
  return mutationOptions;
};

export const submitUserVideoVerificationLocationUploadQueryKey = (
  options: Options<SubmitUserVideoVerificationLocationUploadData>,
) => createQueryKey('submitUserVideoVerificationLocationUpload', options);

/**
 * Submit User Video Verification Location Upload
 */
export const submitUserVideoVerificationLocationUploadOptions = (
  options: Options<SubmitUserVideoVerificationLocationUploadData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await submitUserVideoVerificationLocationUpload({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: submitUserVideoVerificationLocationUploadQueryKey(options),
  });
};

/**
 * Submit User Video Verification Location Upload
 */
export const submitUserVideoVerificationLocationUploadMutation = (
  options?: Partial<Options<SubmitUserVideoVerificationLocationUploadData>>,
): UseMutationOptions<
  SubmitUserVideoVerificationLocationUploadResponse,
  AxiosError<SubmitUserVideoVerificationLocationUploadError>,
  Options<SubmitUserVideoVerificationLocationUploadData>
> => {
  const mutationOptions: UseMutationOptions<
    SubmitUserVideoVerificationLocationUploadResponse,
    AxiosError<SubmitUserVideoVerificationLocationUploadError>,
    Options<SubmitUserVideoVerificationLocationUploadData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await submitUserVideoVerificationLocationUpload({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const executeUserVideoVerificationLocationUploadQueryKey = (
  options: Options<ExecuteUserVideoVerificationLocationUploadData>,
) => createQueryKey('executeUserVideoVerificationLocationUpload', options);

/**
 * Execute User Video Verification Location Upload
 */
export const executeUserVideoVerificationLocationUploadOptions = (
  options: Options<ExecuteUserVideoVerificationLocationUploadData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await executeUserVideoVerificationLocationUpload({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: executeUserVideoVerificationLocationUploadQueryKey(options),
  });
};

/**
 * Execute User Video Verification Location Upload
 */
export const executeUserVideoVerificationLocationUploadMutation = (
  options?: Partial<Options<ExecuteUserVideoVerificationLocationUploadData>>,
): UseMutationOptions<
  unknown,
  AxiosError<ExecuteUserVideoVerificationLocationUploadError>,
  Options<ExecuteUserVideoVerificationLocationUploadData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<ExecuteUserVideoVerificationLocationUploadError>,
    Options<ExecuteUserVideoVerificationLocationUploadData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await executeUserVideoVerificationLocationUpload({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const liveWebhookQueryKey = (options?: Options<LiveWebhookData>) =>
  createQueryKey('liveWebhook', options);

/**
 * Web
 */
export const liveWebhookOptions = (options?: Options<LiveWebhookData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await liveWebhook({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: liveWebhookQueryKey(options),
  });
};

/**
 * Web
 */
export const liveWebhookMutation = (
  options?: Partial<Options<LiveWebhookData>>,
): UseMutationOptions<
  LiveWebhookResponse,
  AxiosError<LiveWebhookError>,
  Options<LiveWebhookData>
> => {
  const mutationOptions: UseMutationOptions<
    LiveWebhookResponse,
    AxiosError<LiveWebhookError>,
    Options<LiveWebhookData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await liveWebhook({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLiveStreamTokenQueryKey = (
  options: Options<GetLiveStreamTokenData>,
) => createQueryKey('getLiveStreamToken', options);

/**
 * Get Live Stream Token
 */
export const getLiveStreamTokenOptions = (
  options: Options<GetLiveStreamTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLiveStreamToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLiveStreamTokenQueryKey(options),
  });
};

export const startLiveQueryKey = (options: Options<StartLiveData>) =>
  createQueryKey('startLive', options);

/**
 * Start Live
 */
export const startLiveOptions = (options: Options<StartLiveData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await startLive({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: startLiveQueryKey(options),
  });
};

/**
 * Start Live
 */
export const startLiveMutation = (
  options?: Partial<Options<StartLiveData>>,
): UseMutationOptions<
  StartLiveResponse2,
  AxiosError<StartLiveError>,
  Options<StartLiveData>
> => {
  const mutationOptions: UseMutationOptions<
    StartLiveResponse2,
    AxiosError<StartLiveError>,
    Options<StartLiveData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await startLive({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const stopLiveQueryKey = (options: Options<StopLiveData>) =>
  createQueryKey('stopLive', options);

/**
 * Stop Live
 */
export const stopLiveOptions = (options: Options<StopLiveData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await stopLive({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: stopLiveQueryKey(options),
  });
};

/**
 * Stop Live
 */
export const stopLiveMutation = (
  options?: Partial<Options<StopLiveData>>,
): UseMutationOptions<
  unknown,
  AxiosError<StopLiveError>,
  Options<StopLiveData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<StopLiveError>,
    Options<StopLiveData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await stopLive({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createUserQueryKey = (options: Options<CreateUserData>) =>
  createQueryKey('createUser', options);

/**
 * Create User
 */
export const createUserOptions = (options: Options<CreateUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserQueryKey(options),
  });
};

/**
 * Create User
 */
export const createUserMutation = (
  options?: Partial<Options<CreateUserData>>,
): UseMutationOptions<
  CreateUserResponse,
  AxiosError<CreateUserError>,
  Options<CreateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUserResponse,
    AxiosError<CreateUserError>,
    Options<CreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserQueryKey = (options?: Options<GetUserData>) =>
  createQueryKey('getUser', options);

/**
 * Get User
 */
export const getUserOptions = (options?: Options<GetUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserQueryKey(options),
  });
};

export const updateVerificationVisibilityQueryKey = (
  options: Options<UpdateVerificationVisibilityData>,
) => createQueryKey('updateVerificationVisibility', options);

/**
 * Update Verification Visibility
 */
export const updateVerificationVisibilityOptions = (
  options: Options<UpdateVerificationVisibilityData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await updateVerificationVisibility({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: updateVerificationVisibilityQueryKey(options),
  });
};

/**
 * Update Verification Visibility
 */
export const updateVerificationVisibilityMutation = (
  options?: Partial<Options<UpdateVerificationVisibilityData>>,
): UseMutationOptions<
  UpdateVerificationVisibilityResponse,
  AxiosError<UpdateVerificationVisibilityError>,
  Options<UpdateVerificationVisibilityData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateVerificationVisibilityResponse,
    AxiosError<UpdateVerificationVisibilityError>,
    Options<UpdateVerificationVisibilityData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateVerificationVisibility({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getVerificationsQueryKey = (
  options?: Options<GetVerificationsData>,
) => createQueryKey('getVerifications', options);

/**
 * Get Verifications
 */
export const getVerificationsOptions = (
  options?: Options<GetVerificationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getVerifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getVerificationsQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getVerificationsInfiniteQueryKey = (
  options?: Options<GetVerificationsData>,
): QueryKey<Options<GetVerificationsData>> =>
  createQueryKey('getVerifications', options, true);

/**
 * Get Verifications
 */
export const getVerificationsInfiniteOptions = (
  options?: Options<GetVerificationsData>,
) => {
  return infiniteQueryOptions<
    GetVerificationsResponse,
    AxiosError<GetVerificationsError>,
    InfiniteData<GetVerificationsResponse>,
    QueryKey<Options<GetVerificationsData>>,
    | number
    | Pick<
        QueryKey<Options<GetVerificationsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetVerificationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getVerifications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getVerificationsInfiniteQueryKey(options),
    },
  );
};

export const getUserVerificationQueryKey = (
  options: Options<GetUserVerificationData>,
) => createQueryKey('getUserVerification', options);

/**
 * Get User Verification
 */
export const getUserVerificationOptions = (
  options: Options<GetUserVerificationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserVerification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserVerificationQueryKey(options),
  });
};

/**
 * Update User
 */
export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>,
): UseMutationOptions<
  UpdateUserResponse,
  AxiosError<UpdateUserError>,
  Options<UpdateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    AxiosError<UpdateUserError>,
    Options<UpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Upsert Fcm
 */
export const upsertFcmMutation = (
  options?: Partial<Options<UpsertFcmData>>,
): UseMutationOptions<
  UpsertFcmResponse,
  AxiosError<DefaultError>,
  Options<UpsertFcmData>
> => {
  const mutationOptions: UseMutationOptions<
    UpsertFcmResponse,
    AxiosError<DefaultError>,
    Options<UpsertFcmData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await upsertFcm({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFcmTokenQueryKey = (options?: Options<GetFcmTokenData>) =>
  createQueryKey('getFcmToken', options);

/**
 * Get Fcm Token
 */
export const getFcmTokenOptions = (options?: Options<GetFcmTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFcmToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFcmTokenQueryKey(options),
  });
};

/**
 * Delete Fcm
 */
export const deleteFcmMutation = (
  options?: Partial<Options<DeleteFcmData>>,
): UseMutationOptions<
  DeleteFcmResponse,
  AxiosError<DefaultError>,
  Options<DeleteFcmData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFcmResponse,
    AxiosError<DefaultError>,
    Options<DeleteFcmData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFcm({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserLocationQueryKey = (
  options: Options<GetUserLocationData>,
) => createQueryKey('getUserLocation', options);

/**
 * Get User Location
 */
export const getUserLocationOptions = (
  options: Options<GetUserLocationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserLocation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserLocationQueryKey(options),
  });
};

/**
 * Get User Location
 */
export const getUserLocationMutation = (
  options?: Partial<Options<GetUserLocationData>>,
): UseMutationOptions<
  GetUserLocationResponse,
  AxiosError<GetUserLocationError>,
  Options<GetUserLocationData>
> => {
  const mutationOptions: UseMutationOptions<
    GetUserLocationResponse,
    AxiosError<GetUserLocationError>,
    Options<GetUserLocationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await getUserLocation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete User
 */
export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>,
): UseMutationOptions<
  DeleteUserResponse,
  AxiosError<DefaultError>,
  Options<DeleteUserData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    AxiosError<DefaultError>,
    Options<DeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const checkRegisteredUsersQueryKey = (
  options: Options<CheckRegisteredUsersData>,
) => createQueryKey('checkRegisteredUsers', options);

/**
 * Check Registered Users
 */
export const checkRegisteredUsersOptions = (
  options: Options<CheckRegisteredUsersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkRegisteredUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkRegisteredUsersQueryKey(options),
  });
};

/**
 * Check Registered Users
 */
export const checkRegisteredUsersMutation = (
  options?: Partial<Options<CheckRegisteredUsersData>>,
): UseMutationOptions<
  CheckRegisteredUsersResponse,
  AxiosError<CheckRegisteredUsersError>,
  Options<CheckRegisteredUsersData>
> => {
  const mutationOptions: UseMutationOptions<
    CheckRegisteredUsersResponse,
    AxiosError<CheckRegisteredUsersError>,
    Options<CheckRegisteredUsersData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await checkRegisteredUsers({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const blockUserBlockTargetIdPostQueryKey = (
  options: Options<BlockUserBlockTargetIdPostData>,
) => createQueryKey('blockUserBlockTargetIdPost', options);

/**
 * Block
 */
export const blockUserBlockTargetIdPostOptions = (
  options: Options<BlockUserBlockTargetIdPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await blockUserBlockTargetIdPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: blockUserBlockTargetIdPostQueryKey(options),
  });
};

/**
 * Block
 */
export const blockUserBlockTargetIdPostMutation = (
  options?: Partial<Options<BlockUserBlockTargetIdPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<BlockUserBlockTargetIdPostError>,
  Options<BlockUserBlockTargetIdPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<BlockUserBlockTargetIdPostError>,
    Options<BlockUserBlockTargetIdPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await blockUserBlockTargetIdPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const unblockUserUnblockTargetIdPostQueryKey = (
  options: Options<UnblockUserUnblockTargetIdPostData>,
) => createQueryKey('unblockUserUnblockTargetIdPost', options);

/**
 * Unblock
 */
export const unblockUserUnblockTargetIdPostOptions = (
  options: Options<UnblockUserUnblockTargetIdPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await unblockUserUnblockTargetIdPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: unblockUserUnblockTargetIdPostQueryKey(options),
  });
};

/**
 * Unblock
 */
export const unblockUserUnblockTargetIdPostMutation = (
  options?: Partial<Options<UnblockUserUnblockTargetIdPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<UnblockUserUnblockTargetIdPostError>,
  Options<UnblockUserUnblockTargetIdPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<UnblockUserUnblockTargetIdPostError>,
    Options<UnblockUserUnblockTargetIdPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await unblockUserUnblockTargetIdPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reportUserReportTargetIdPostQueryKey = (
  options: Options<ReportUserReportTargetIdPostData>,
) => createQueryKey('reportUserReportTargetIdPost', options);

/**
 * Report
 */
export const reportUserReportTargetIdPostOptions = (
  options: Options<ReportUserReportTargetIdPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reportUserReportTargetIdPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reportUserReportTargetIdPostQueryKey(options),
  });
};

/**
 * Report
 */
export const reportUserReportTargetIdPostMutation = (
  options?: Partial<Options<ReportUserReportTargetIdPostData>>,
): UseMutationOptions<
  ReportUserReportTargetIdPostResponse,
  AxiosError<ReportUserReportTargetIdPostError>,
  Options<ReportUserReportTargetIdPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ReportUserReportTargetIdPostResponse,
    AxiosError<ReportUserReportTargetIdPostError>,
    Options<ReportUserReportTargetIdPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await reportUserReportTargetIdPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const checkUsernameUserCheckUsernameUsernameGetQueryKey = (
  options: Options<CheckUsernameUserCheckUsernameUsernameGetData>,
) => createQueryKey('checkUsernameUserCheckUsernameUsernameGet', options);

/**
 * Check Username
 */
export const checkUsernameUserCheckUsernameUsernameGetOptions = (
  options: Options<CheckUsernameUserCheckUsernameUsernameGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkUsernameUserCheckUsernameUsernameGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkUsernameUserCheckUsernameUsernameGetQueryKey(options),
  });
};

export const getUserProfileUserProfileUserIdGetQueryKey = (
  options: Options<GetUserProfileUserProfileUserIdGetData>,
) => createQueryKey('getUserProfileUserProfileUserIdGet', options);

/**
 * Get User Profile
 */
export const getUserProfileUserProfileUserIdGetOptions = (
  options: Options<GetUserProfileUserProfileUserIdGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserProfileUserProfileUserIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserProfileUserProfileUserIdGetQueryKey(options),
  });
};

export const getUserProfileByUsernameQueryKey = (
  options: Options<GetUserProfileByUsernameData>,
) => createQueryKey('getUserProfileByUsername', options);

/**
 * Get User Profile By Username
 */
export const getUserProfileByUsernameOptions = (
  options: Options<GetUserProfileByUsernameData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserProfileByUsername({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserProfileByUsernameQueryKey(options),
  });
};

export const getLocationFeedPaginatedQueryKey = (
  options: Options<GetLocationFeedPaginatedData>,
) => createQueryKey('getLocationFeedPaginated', options);

/**
 * Get Location Feed Paginated
 */
export const getLocationFeedPaginatedOptions = (
  options: Options<GetLocationFeedPaginatedData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLocationFeedPaginated({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLocationFeedPaginatedQueryKey(options),
  });
};

export const getLocationFeedPaginatedInfiniteQueryKey = (
  options: Options<GetLocationFeedPaginatedData>,
): QueryKey<Options<GetLocationFeedPaginatedData>> =>
  createQueryKey('getLocationFeedPaginated', options, true);

/**
 * Get Location Feed Paginated
 */
export const getLocationFeedPaginatedInfiniteOptions = (
  options: Options<GetLocationFeedPaginatedData>,
) => {
  return infiniteQueryOptions<
    GetLocationFeedPaginatedResponse,
    AxiosError<GetLocationFeedPaginatedError>,
    InfiniteData<GetLocationFeedPaginatedResponse>,
    QueryKey<Options<GetLocationFeedPaginatedData>>,
    | number
    | Pick<
        QueryKey<Options<GetLocationFeedPaginatedData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetLocationFeedPaginatedData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getLocationFeedPaginated({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getLocationFeedPaginatedInfiniteQueryKey(options),
    },
  );
};

export const sendFriendRequestQueryKey = (
  options: Options<SendFriendRequestData>,
) => createQueryKey('sendFriendRequest', options);

/**
 * Send Friend Request
 */
export const sendFriendRequestOptions = (
  options: Options<SendFriendRequestData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sendFriendRequest({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: sendFriendRequestQueryKey(options),
  });
};

/**
 * Send Friend Request
 */
export const sendFriendRequestMutation = (
  options?: Partial<Options<SendFriendRequestData>>,
): UseMutationOptions<
  SendFriendRequestResponse,
  AxiosError<SendFriendRequestError>,
  Options<SendFriendRequestData>
> => {
  const mutationOptions: UseMutationOptions<
    SendFriendRequestResponse,
    AxiosError<SendFriendRequestError>,
    Options<SendFriendRequestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await sendFriendRequest({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFriendRequestsQueryKey = (
  options?: Options<GetFriendRequestsData>,
) => createQueryKey('getFriendRequests', options);

/**
 * Get Friend Requests
 */
export const getFriendRequestsOptions = (
  options?: Options<GetFriendRequestsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFriendRequests({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFriendRequestsQueryKey(options),
  });
};

/**
 * Accept Friend Request
 */
export const acceptFriendRequestMutation = (
  options?: Partial<Options<AcceptFriendRequestData>>,
): UseMutationOptions<
  unknown,
  AxiosError<AcceptFriendRequestError>,
  Options<AcceptFriendRequestData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<AcceptFriendRequestError>,
    Options<AcceptFriendRequestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await acceptFriendRequest({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reject Friend Request
 */
export const rejectFriendRequestMutation = (
  options?: Partial<Options<RejectFriendRequestData>>,
): UseMutationOptions<
  unknown,
  AxiosError<RejectFriendRequestError>,
  Options<RejectFriendRequestData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<RejectFriendRequestError>,
    Options<RejectFriendRequestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await rejectFriendRequest({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFriendsListQueryKey = (options?: Options<GetFriendsListData>) =>
  createQueryKey('getFriendsList', options);

/**
 * Get Friends List
 */
export const getFriendsListOptions = (
  options?: Options<GetFriendsListData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFriendsList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFriendsListQueryKey(options),
  });
};

export const getFriendsListInfiniteQueryKey = (
  options?: Options<GetFriendsListData>,
): QueryKey<Options<GetFriendsListData>> =>
  createQueryKey('getFriendsList', options, true);

/**
 * Get Friends List
 */
export const getFriendsListInfiniteOptions = (
  options?: Options<GetFriendsListData>,
) => {
  return infiniteQueryOptions<
    GetFriendsListResponse,
    AxiosError<GetFriendsListError>,
    InfiniteData<GetFriendsListResponse>,
    QueryKey<Options<GetFriendsListData>>,
    | number
    | Pick<
        QueryKey<Options<GetFriendsListData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetFriendsListData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getFriendsList({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getFriendsListInfiniteQueryKey(options),
    },
  );
};

/**
 * Remove Friend
 */
export const removeFriendMutation = (
  options?: Partial<Options<RemoveFriendData>>,
): UseMutationOptions<
  unknown,
  AxiosError<RemoveFriendError>,
  Options<RemoveFriendData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<RemoveFriendError>,
    Options<RemoveFriendData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await removeFriend({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getBlockedFriendsQueryKey = (
  options?: Options<GetBlockedFriendsData>,
) => createQueryKey('getBlockedFriends', options);

/**
 * Blocked Friends
 */
export const getBlockedFriendsOptions = (
  options?: Options<GetBlockedFriendsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBlockedFriends({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBlockedFriendsQueryKey(options),
  });
};

export const updateMessageStateChatUpdateMessagesPostQueryKey = (
  options: Options<UpdateMessageStateChatUpdateMessagesPostData>,
) => createQueryKey('updateMessageStateChatUpdateMessagesPost', options);

/**
 * Update Message State
 */
export const updateMessageStateChatUpdateMessagesPostOptions = (
  options: Options<UpdateMessageStateChatUpdateMessagesPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await updateMessageStateChatUpdateMessagesPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: updateMessageStateChatUpdateMessagesPostQueryKey(options),
  });
};

/**
 * Update Message State
 */
export const updateMessageStateChatUpdateMessagesPostMutation = (
  options?: Partial<Options<UpdateMessageStateChatUpdateMessagesPostData>>,
): UseMutationOptions<
  UpdateMessageStateChatUpdateMessagesPostResponse,
  AxiosError<UpdateMessageStateChatUpdateMessagesPostError>,
  Options<UpdateMessageStateChatUpdateMessagesPostData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateMessageStateChatUpdateMessagesPostResponse,
    AxiosError<UpdateMessageStateChatUpdateMessagesPostError>,
    Options<UpdateMessageStateChatUpdateMessagesPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateMessageStateChatUpdateMessagesPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMessagesChatMessagesGetQueryKey = (
  options: Options<GetMessagesChatMessagesGetData>,
) => createQueryKey('getMessagesChatMessagesGet', options);

/**
 * Get Messages
 */
export const getMessagesChatMessagesGetOptions = (
  options: Options<GetMessagesChatMessagesGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMessagesChatMessagesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMessagesChatMessagesGetQueryKey(options),
  });
};

export const getMessagesChatMessagesGetInfiniteQueryKey = (
  options: Options<GetMessagesChatMessagesGetData>,
): QueryKey<Options<GetMessagesChatMessagesGetData>> =>
  createQueryKey('getMessagesChatMessagesGet', options, true);

/**
 * Get Messages
 */
export const getMessagesChatMessagesGetInfiniteOptions = (
  options: Options<GetMessagesChatMessagesGetData>,
) => {
  return infiniteQueryOptions<
    GetMessagesChatMessagesGetResponse,
    AxiosError<GetMessagesChatMessagesGetError>,
    InfiniteData<GetMessagesChatMessagesGetResponse>,
    QueryKey<Options<GetMessagesChatMessagesGetData>>,
    | number
    | Pick<
        QueryKey<Options<GetMessagesChatMessagesGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetMessagesChatMessagesGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getMessagesChatMessagesGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getMessagesChatMessagesGetInfiniteQueryKey(options),
    },
  );
};

export const getUserChatRoomsQueryKey = (
  options?: Options<GetUserChatRoomsData>,
) => createQueryKey('getUserChatRooms', options);

/**
 * Get User Chat Rooms
 */
export const getUserChatRoomsOptions = (
  options?: Options<GetUserChatRoomsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserChatRooms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserChatRoomsQueryKey(options),
  });
};

export const createChatRoomQueryKey = (options: Options<CreateChatRoomData>) =>
  createQueryKey('createChatRoom', options);

/**
 * Create Chat Room
 */
export const createChatRoomOptions = (options: Options<CreateChatRoomData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createChatRoom({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createChatRoomQueryKey(options),
  });
};

/**
 * Create Chat Room
 */
export const createChatRoomMutation = (
  options?: Partial<Options<CreateChatRoomData>>,
): UseMutationOptions<
  CreateChatRoomResponse2,
  AxiosError<CreateChatRoomError>,
  Options<CreateChatRoomData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateChatRoomResponse2,
    AxiosError<CreateChatRoomError>,
    Options<CreateChatRoomData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createChatRoom({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const expireChatRoomChatExpireChatRoomPostQueryKey = (
  options: Options<ExpireChatRoomChatExpireChatRoomPostData>,
) => createQueryKey('expireChatRoomChatExpireChatRoomPost', options);

/**
 * Expire Chat Room
 */
export const expireChatRoomChatExpireChatRoomPostOptions = (
  options: Options<ExpireChatRoomChatExpireChatRoomPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await expireChatRoomChatExpireChatRoomPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: expireChatRoomChatExpireChatRoomPostQueryKey(options),
  });
};

/**
 * Expire Chat Room
 */
export const expireChatRoomChatExpireChatRoomPostMutation = (
  options?: Partial<Options<ExpireChatRoomChatExpireChatRoomPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<ExpireChatRoomChatExpireChatRoomPostError>,
  Options<ExpireChatRoomChatExpireChatRoomPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<ExpireChatRoomChatExpireChatRoomPostError>,
    Options<ExpireChatRoomChatExpireChatRoomPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await expireChatRoomChatExpireChatRoomPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const sendPublicKeyChatSendPublicKeyPostQueryKey = (
  options: Options<SendPublicKeyChatSendPublicKeyPostData>,
) => createQueryKey('sendPublicKeyChatSendPublicKeyPost', options);

/**
 * Send Public Key
 */
export const sendPublicKeyChatSendPublicKeyPostOptions = (
  options: Options<SendPublicKeyChatSendPublicKeyPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sendPublicKeyChatSendPublicKeyPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: sendPublicKeyChatSendPublicKeyPostQueryKey(options),
  });
};

/**
 * Send Public Key
 */
export const sendPublicKeyChatSendPublicKeyPostMutation = (
  options?: Partial<Options<SendPublicKeyChatSendPublicKeyPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<SendPublicKeyChatSendPublicKeyPostError>,
  Options<SendPublicKeyChatSendPublicKeyPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<SendPublicKeyChatSendPublicKeyPostError>,
    Options<SendPublicKeyChatSendPublicKeyPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await sendPublicKeyChatSendPublicKeyPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMessageChatRoomQueryKey = (
  options: Options<GetMessageChatRoomData>,
) => createQueryKey('getMessageChatRoom', options);

/**
 * Get Chat Room
 */
export const getMessageChatRoomOptions = (
  options: Options<GetMessageChatRoomData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMessageChatRoom({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMessageChatRoomQueryKey(options),
  });
};

export const getNotificationsQueryKey = (
  options?: Options<GetNotificationsData>,
) => createQueryKey('getNotifications', options);

/**
 * Get Notifications
 */
export const getNotificationsOptions = (
  options?: Options<GetNotificationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getNotifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getNotificationsQueryKey(options),
  });
};

export const getNotificationsInfiniteQueryKey = (
  options?: Options<GetNotificationsData>,
): QueryKey<Options<GetNotificationsData>> =>
  createQueryKey('getNotifications', options, true);

/**
 * Get Notifications
 */
export const getNotificationsInfiniteOptions = (
  options?: Options<GetNotificationsData>,
) => {
  return infiniteQueryOptions<
    GetNotificationsResponse,
    AxiosError<GetNotificationsError>,
    InfiniteData<GetNotificationsResponse>,
    QueryKey<Options<GetNotificationsData>>,
    | number
    | Pick<
        QueryKey<Options<GetNotificationsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetNotificationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNotifications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getNotificationsInfiniteQueryKey(options),
    },
  );
};

export const markNotificationsReadQueryKey = (
  options?: Options<MarkNotificationsReadData>,
) => createQueryKey('markNotificationsRead', options);

/**
 * Mark Notifications Read
 */
export const markNotificationsReadOptions = (
  options?: Options<MarkNotificationsReadData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await markNotificationsRead({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: markNotificationsReadQueryKey(options),
  });
};

/**
 * Mark Notifications Read
 */
export const markNotificationsReadMutation = (
  options?: Partial<Options<MarkNotificationsReadData>>,
): UseMutationOptions<
  MarkNotificationsReadResponse2,
  AxiosError<DefaultError>,
  Options<MarkNotificationsReadData>
> => {
  const mutationOptions: UseMutationOptions<
    MarkNotificationsReadResponse2,
    AxiosError<DefaultError>,
    Options<MarkNotificationsReadData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await markNotificationsRead({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUnreadCountQueryKey = (options?: Options<GetUnreadCountData>) =>
  createQueryKey('getUnreadCount', options);

/**
 * Get Unread Count
 */
export const getUnreadCountOptions = (
  options?: Options<GetUnreadCountData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUnreadCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUnreadCountQueryKey(options),
  });
};

export const pokeUserLiveActionsPokeTargetUserIdPostQueryKey = (
  options: Options<PokeUserLiveActionsPokeTargetUserIdPostData>,
) => createQueryKey('pokeUserLiveActionsPokeTargetUserIdPost', options);

/**
 * Poke User
 */
export const pokeUserLiveActionsPokeTargetUserIdPostOptions = (
  options: Options<PokeUserLiveActionsPokeTargetUserIdPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pokeUserLiveActionsPokeTargetUserIdPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pokeUserLiveActionsPokeTargetUserIdPostQueryKey(options),
  });
};

/**
 * Poke User
 */
export const pokeUserLiveActionsPokeTargetUserIdPostMutation = (
  options?: Partial<Options<PokeUserLiveActionsPokeTargetUserIdPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<PokeUserLiveActionsPokeTargetUserIdPostError>,
  Options<PokeUserLiveActionsPokeTargetUserIdPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<PokeUserLiveActionsPokeTargetUserIdPostError>,
    Options<PokeUserLiveActionsPokeTargetUserIdPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await pokeUserLiveActionsPokeTargetUserIdPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const messageUserLiveActionsMessageTargetUserIdPostQueryKey = (
  options: Options<MessageUserLiveActionsMessageTargetUserIdPostData>,
) => createQueryKey('messageUserLiveActionsMessageTargetUserIdPost', options);

/**
 * Message User
 */
export const messageUserLiveActionsMessageTargetUserIdPostOptions = (
  options: Options<MessageUserLiveActionsMessageTargetUserIdPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await messageUserLiveActionsMessageTargetUserIdPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: messageUserLiveActionsMessageTargetUserIdPostQueryKey(options),
  });
};

/**
 * Message User
 */
export const messageUserLiveActionsMessageTargetUserIdPostMutation = (
  options?: Partial<Options<MessageUserLiveActionsMessageTargetUserIdPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<MessageUserLiveActionsMessageTargetUserIdPostError>,
  Options<MessageUserLiveActionsMessageTargetUserIdPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<MessageUserLiveActionsMessageTargetUserIdPostError>,
    Options<MessageUserLiveActionsMessageTargetUserIdPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await messageUserLiveActionsMessageTargetUserIdPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const likeVerificationQueryKey = (
  options: Options<LikeVerificationData>,
) => createQueryKey('likeVerification', options);

/**
 * Like Verification
 */
export const likeVerificationOptions = (
  options: Options<LikeVerificationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await likeVerification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: likeVerificationQueryKey(options),
  });
};

/**
 * Like Verification
 */
export const likeVerificationMutation = (
  options?: Partial<Options<LikeVerificationData>>,
): UseMutationOptions<
  LikeVerificationResponse2,
  AxiosError<LikeVerificationError>,
  Options<LikeVerificationData>
> => {
  const mutationOptions: UseMutationOptions<
    LikeVerificationResponse2,
    AxiosError<LikeVerificationError>,
    Options<LikeVerificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await likeVerification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unlike Verification
 */
export const unlikeVerificationMutation = (
  options?: Partial<Options<UnlikeVerificationData>>,
): UseMutationOptions<
  UnlikeVerificationResponse2,
  AxiosError<UnlikeVerificationError>,
  Options<UnlikeVerificationData>
> => {
  const mutationOptions: UseMutationOptions<
    UnlikeVerificationResponse2,
    AxiosError<UnlikeVerificationError>,
    Options<UnlikeVerificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await unlikeVerification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getVerificationLikesCountQueryKey = (
  options: Options<GetVerificationLikesCountData>,
) => createQueryKey('getVerificationLikesCount', options);

/**
 * Get Verification Likes Count
 */
export const getVerificationLikesCountOptions = (
  options: Options<GetVerificationLikesCountData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getVerificationLikesCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getVerificationLikesCountQueryKey(options),
  });
};

export const trackImpressionsQueryKey = (
  options: Options<TrackImpressionsData>,
) => createQueryKey('trackImpressions', options);

/**
 * Track Impressions
 */
export const trackImpressionsOptions = (
  options: Options<TrackImpressionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await trackImpressions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: trackImpressionsQueryKey(options),
  });
};

/**
 * Track Impressions
 */
export const trackImpressionsMutation = (
  options?: Partial<Options<TrackImpressionsData>>,
): UseMutationOptions<
  TrackImpressionsResponse2,
  AxiosError<TrackImpressionsError>,
  Options<TrackImpressionsData>
> => {
  const mutationOptions: UseMutationOptions<
    TrackImpressionsResponse2,
    AxiosError<TrackImpressionsError>,
    Options<TrackImpressionsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await trackImpressions({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getImpressionsCountQueryKey = (
  options: Options<GetImpressionsCountData>,
) => createQueryKey('getImpressionsCount', options);

/**
 * Get Impressions Count
 */
export const getImpressionsCountOptions = (
  options: Options<GetImpressionsCountData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getImpressionsCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getImpressionsCountQueryKey(options),
  });
};

export const rateFactCheckQueryKey = (options: Options<RateFactCheckData>) =>
  createQueryKey('rateFactCheck', options);

/**
 * Rate Fact Check
 */
export const rateFactCheckOptions = (options: Options<RateFactCheckData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rateFactCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rateFactCheckQueryKey(options),
  });
};

/**
 * Rate Fact Check
 */
export const rateFactCheckMutation = (
  options?: Partial<Options<RateFactCheckData>>,
): UseMutationOptions<
  RateFactCheckResponse2,
  AxiosError<RateFactCheckError>,
  Options<RateFactCheckData>
> => {
  const mutationOptions: UseMutationOptions<
    RateFactCheckResponse2,
    AxiosError<RateFactCheckError>,
    Options<RateFactCheckData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await rateFactCheck({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unrate Fact Check
 */
export const unrateFactCheckMutation = (
  options?: Partial<Options<UnrateFactCheckData>>,
): UseMutationOptions<
  UnrateFactCheckResponse2,
  AxiosError<UnrateFactCheckError>,
  Options<UnrateFactCheckData>
> => {
  const mutationOptions: UseMutationOptions<
    UnrateFactCheckResponse2,
    AxiosError<UnrateFactCheckError>,
    Options<UnrateFactCheckData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await unrateFactCheck({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFactCheckRatingsCountQueryKey = (
  options: Options<GetFactCheckRatingsCountData>,
) => createQueryKey('getFactCheckRatingsCount', options);

/**
 * Get Fact Check Ratings Count
 */
export const getFactCheckRatingsCountOptions = (
  options: Options<GetFactCheckRatingsCountData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFactCheckRatingsCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFactCheckRatingsCountQueryKey(options),
  });
};

export const getFactCheckQueryKey = (options: Options<GetFactCheckData>) =>
  createQueryKey('getFactCheck', options);

/**
 * Get Fact Check
 */
export const getFactCheckOptions = (options: Options<GetFactCheckData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFactCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFactCheckQueryKey(options),
  });
};

export const getRoomPreviewDataQueryKey = (
  options: Options<GetRoomPreviewDataData>,
) => createQueryKey('getRoomPreviewData', options);

/**
 * Get Room Preview Data
 */
export const getRoomPreviewDataOptions = (
  options: Options<GetRoomPreviewDataData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRoomPreviewData({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRoomPreviewDataQueryKey(options),
  });
};

export const stopStreamQueryKey = (options: Options<StopStreamData>) =>
  createQueryKey('stopStream', options);

/**
 * Stop Stream
 */
export const stopStreamOptions = (options: Options<StopStreamData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await stopStream({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: stopStreamQueryKey(options),
  });
};

/**
 * Stop Stream
 */
export const stopStreamMutation = (
  options?: Partial<Options<StopStreamData>>,
): UseMutationOptions<
  unknown,
  AxiosError<StopStreamError>,
  Options<StopStreamData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<StopStreamError>,
    Options<StopStreamData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await stopStream({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createStreamQueryKey = (options: Options<CreateStreamData>) =>
  createQueryKey('createStream', options);

/**
 * Create Stream
 */
export const createStreamOptions = (options: Options<CreateStreamData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createStream({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createStreamQueryKey(options),
  });
};

/**
 * Create Stream
 */
export const createStreamMutation = (
  options?: Partial<Options<CreateStreamData>>,
): UseMutationOptions<
  unknown,
  AxiosError<CreateStreamError>,
  Options<CreateStreamData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<CreateStreamError>,
    Options<CreateStreamData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createStream({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createSpaceQueryKey = (options?: Options<CreateSpaceData>) =>
  createQueryKey('createSpace', options);

/**
 * Create Space
 * Creates a 'space' (analogous to a LiveKit room) and inserts a new Verification document.
 * - If scheduled_at is in the future, we set the space_state to 'scheduled'.
 * - If no scheduled_at, we treat it as 'started' immediately.
 * - Optionally insert text_content to the verification doc.
 * - Also store 'creator_identity' with x_user_id in the doc and plan to store metadata in livekit.
 */
export const createSpaceOptions = (options?: Options<CreateSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createSpaceQueryKey(options),
  });
};

/**
 * Create Space
 * Creates a 'space' (analogous to a LiveKit room) and inserts a new Verification document.
 * - If scheduled_at is in the future, we set the space_state to 'scheduled'.
 * - If no scheduled_at, we treat it as 'started' immediately.
 * - Optionally insert text_content to the verification doc.
 * - Also store 'creator_identity' with x_user_id in the doc and plan to store metadata in livekit.
 */
export const createSpaceMutation = (
  options?: Partial<Options<CreateSpaceData>>,
): UseMutationOptions<
  CreateSpaceResponse2,
  AxiosError<CreateSpaceError>,
  Options<CreateSpaceData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateSpaceResponse2,
    AxiosError<CreateSpaceError>,
    Options<CreateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const inviteToStageQueryKey = (options: Options<InviteToStageData>) =>
  createQueryKey('inviteToStage', options);

/**
 * Invite To Stage
 * Allows the creator (x_user_id) to invite another participant (invitee_identity) to the stage by giving them publish permissions if they had their hand raised.
 */
export const inviteToStageOptions = (options: Options<InviteToStageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await inviteToStage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: inviteToStageQueryKey(options),
  });
};

/**
 * Invite To Stage
 * Allows the creator (x_user_id) to invite another participant (invitee_identity) to the stage by giving them publish permissions if they had their hand raised.
 */
export const inviteToStageMutation = (
  options?: Partial<Options<InviteToStageData>>,
): UseMutationOptions<
  unknown,
  AxiosError<InviteToStageError>,
  Options<InviteToStageData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<InviteToStageError>,
    Options<InviteToStageData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await inviteToStage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const removeFromStageQueryKey = (
  options: Options<RemoveFromStageData>,
) => createQueryKey('removeFromStage', options);

/**
 * Remove From Stage
 * Removes participant from stage.
 * If participant_identity not given, remove the caller themself from stage.
 */
export const removeFromStageOptions = (
  options: Options<RemoveFromStageData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await removeFromStage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: removeFromStageQueryKey(options),
  });
};

/**
 * Remove From Stage
 * Removes participant from stage.
 * If participant_identity not given, remove the caller themself from stage.
 */
export const removeFromStageMutation = (
  options?: Partial<Options<RemoveFromStageData>>,
): UseMutationOptions<
  unknown,
  AxiosError<RemoveFromStageError>,
  Options<RemoveFromStageData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<RemoveFromStageError>,
    Options<RemoveFromStageData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await removeFromStage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const raiseHandQueryKey = (options: Options<RaiseHandData>) =>
  createQueryKey('raiseHand', options);

/**
 * Raise Hand
 * Allows participant to set 'hand_raised' = True in metadata.
 * If they've also been invited, canPublish might be granted.
 */
export const raiseHandOptions = (options: Options<RaiseHandData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await raiseHand({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: raiseHandQueryKey(options),
  });
};

/**
 * Raise Hand
 * Allows participant to set 'hand_raised' = True in metadata.
 * If they've also been invited, canPublish might be granted.
 */
export const raiseHandMutation = (
  options?: Partial<Options<RaiseHandData>>,
): UseMutationOptions<
  unknown,
  AxiosError<RaiseHandError>,
  Options<RaiseHandData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<RaiseHandError>,
    Options<RaiseHandData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await raiseHand({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const subscribeSpaceQueryKey = (options: Options<SubscribeSpaceData>) =>
  createQueryKey('subscribeSpace', options);

/**
 * Subscribe Space
 * Allows a user to subscribe to a space.
 * For example, track in a separate 'subscriptions' collection or a user list in the verification doc.
 */
export const subscribeSpaceOptions = (options: Options<SubscribeSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await subscribeSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: subscribeSpaceQueryKey(options),
  });
};

/**
 * Subscribe Space
 * Allows a user to subscribe to a space.
 * For example, track in a separate 'subscriptions' collection or a user list in the verification doc.
 */
export const subscribeSpaceMutation = (
  options?: Partial<Options<SubscribeSpaceData>>,
): UseMutationOptions<
  unknown,
  AxiosError<SubscribeSpaceError>,
  Options<SubscribeSpaceData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<SubscribeSpaceError>,
    Options<SubscribeSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await subscribeSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const triggerSpaceStartQueryKey = (
  options: Options<TriggerSpaceStartData>,
) => createQueryKey('triggerSpaceStart', options);

/**
 * Trigger Space Start
 * Called by a scheduled Cloud Task (or similar) to flip a 'scheduled' space to 'started',
 * then send notifications to all subscribed users in batches.
 */
export const triggerSpaceStartOptions = (
  options: Options<TriggerSpaceStartData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await triggerSpaceStart({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: triggerSpaceStartQueryKey(options),
  });
};

/**
 * Trigger Space Start
 * Called by a scheduled Cloud Task (or similar) to flip a 'scheduled' space to 'started',
 * then send notifications to all subscribed users in batches.
 */
export const triggerSpaceStartMutation = (
  options?: Partial<Options<TriggerSpaceStartData>>,
): UseMutationOptions<
  unknown,
  AxiosError<TriggerSpaceStartError>,
  Options<TriggerSpaceStartData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<TriggerSpaceStartError>,
    Options<TriggerSpaceStartData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await triggerSpaceStart({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createCommentCommentsPostQueryKey = (
  options: Options<CreateCommentCommentsPostData>,
) => createQueryKey('createCommentCommentsPost', options);

/**
 * Create Comment
 */
export const createCommentCommentsPostOptions = (
  options: Options<CreateCommentCommentsPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCommentCommentsPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCommentCommentsPostQueryKey(options),
  });
};

/**
 * Create Comment
 */
export const createCommentCommentsPostMutation = (
  options?: Partial<Options<CreateCommentCommentsPostData>>,
): UseMutationOptions<
  unknown,
  AxiosError<CreateCommentCommentsPostError>,
  Options<CreateCommentCommentsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<CreateCommentCommentsPostError>,
    Options<CreateCommentCommentsPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createCommentCommentsPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getVerificationCommentsQueryKey = (
  options: Options<GetVerificationCommentsData>,
) => createQueryKey('getVerificationComments', options);

/**
 * Get Verification Comments
 */
export const getVerificationCommentsOptions = (
  options: Options<GetVerificationCommentsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getVerificationComments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getVerificationCommentsQueryKey(options),
  });
};

export const getVerificationCommentsInfiniteQueryKey = (
  options: Options<GetVerificationCommentsData>,
): QueryKey<Options<GetVerificationCommentsData>> =>
  createQueryKey('getVerificationComments', options, true);

/**
 * Get Verification Comments
 */
export const getVerificationCommentsInfiniteOptions = (
  options: Options<GetVerificationCommentsData>,
) => {
  return infiniteQueryOptions<
    GetVerificationCommentsResponse2,
    AxiosError<GetVerificationCommentsError>,
    InfiniteData<GetVerificationCommentsResponse2>,
    QueryKey<Options<GetVerificationCommentsData>>,
    | number
    | Pick<
        QueryKey<Options<GetVerificationCommentsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetVerificationCommentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getVerificationComments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getVerificationCommentsInfiniteQueryKey(options),
    },
  );
};

/**
 * Unlike Comment
 */
export const unlikeCommentMutation = (
  options?: Partial<Options<UnlikeCommentData>>,
): UseMutationOptions<
  UnlikeCommentResponse,
  AxiosError<UnlikeCommentError>,
  Options<UnlikeCommentData>
> => {
  const mutationOptions: UseMutationOptions<
    UnlikeCommentResponse,
    AxiosError<UnlikeCommentError>,
    Options<UnlikeCommentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await unlikeComment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const likeCommentQueryKey = (options: Options<LikeCommentData>) =>
  createQueryKey('likeComment', options);

/**
 * Like Comment
 */
export const likeCommentOptions = (options: Options<LikeCommentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await likeComment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: likeCommentQueryKey(options),
  });
};

/**
 * Like Comment
 */
export const likeCommentMutation = (
  options?: Partial<Options<LikeCommentData>>,
): UseMutationOptions<
  LikeCommentResponse2,
  AxiosError<LikeCommentError>,
  Options<LikeCommentData>
> => {
  const mutationOptions: UseMutationOptions<
    LikeCommentResponse2,
    AxiosError<LikeCommentError>,
    Options<LikeCommentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await likeComment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getVerificationCommentsCountQueryKey = (
  options: Options<GetVerificationCommentsCountData>,
) => createQueryKey('getVerificationCommentsCount', options);

/**
 * Get Verification Comments Count
 */
export const getVerificationCommentsCountOptions = (
  options: Options<GetVerificationCommentsCountData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getVerificationCommentsCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getVerificationCommentsCountQueryKey(options),
  });
};

/**
 * Delete Comment Endpoint
 */
export const deleteCommentMutation = (
  options?: Partial<Options<DeleteCommentData>>,
): UseMutationOptions<
  unknown,
  AxiosError<DeleteCommentError>,
  Options<DeleteCommentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<DeleteCommentError>,
    Options<DeleteCommentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteComment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove Reaction
 * Remove the authenticated user's reaction from a comment.
 */
export const removeReactionMutation = (
  options?: Partial<Options<RemoveReactionData>>,
): UseMutationOptions<
  RemoveReactionResponse2,
  AxiosError<RemoveReactionError>,
  Options<RemoveReactionData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveReactionResponse2,
    AxiosError<RemoveReactionError>,
    Options<RemoveReactionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await removeReaction({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCommentReactionsCommentsCommentIdReactionsGetQueryKey = (
  options: Options<GetCommentReactionsCommentsCommentIdReactionsGetData>,
) =>
  createQueryKey('getCommentReactionsCommentsCommentIdReactionsGet', options);

/**
 * Get Comment Reactions
 * Get all reactions for a comment, including the current user's reaction.
 */
export const getCommentReactionsCommentsCommentIdReactionsGetOptions = (
  options: Options<GetCommentReactionsCommentsCommentIdReactionsGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCommentReactionsCommentsCommentIdReactionsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCommentReactionsCommentsCommentIdReactionsGetQueryKey(options),
  });
};

export const addOrUpdateReactionCommentsCommentIdReactionsPostQueryKey = (
  options: Options<AddOrUpdateReactionCommentsCommentIdReactionsPostData>,
) =>
  createQueryKey('addOrUpdateReactionCommentsCommentIdReactionsPost', options);

/**
 * Add Or Update Reaction
 * Add a new reaction or update an existing reaction for a comment.
 * Implements upsert logic - if user already has a reaction, it updates it.
 */
export const addOrUpdateReactionCommentsCommentIdReactionsPostOptions = (
  options: Options<AddOrUpdateReactionCommentsCommentIdReactionsPostData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addOrUpdateReactionCommentsCommentIdReactionsPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey:
      addOrUpdateReactionCommentsCommentIdReactionsPostQueryKey(options),
  });
};

/**
 * Add Or Update Reaction
 * Add a new reaction or update an existing reaction for a comment.
 * Implements upsert logic - if user already has a reaction, it updates it.
 */
export const addOrUpdateReactionCommentsCommentIdReactionsPostMutation = (
  options?: Partial<
    Options<AddOrUpdateReactionCommentsCommentIdReactionsPostData>
  >,
): UseMutationOptions<
  unknown,
  AxiosError<AddOrUpdateReactionCommentsCommentIdReactionsPostError>,
  Options<AddOrUpdateReactionCommentsCommentIdReactionsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<AddOrUpdateReactionCommentsCommentIdReactionsPostError>,
    Options<AddOrUpdateReactionCommentsCommentIdReactionsPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await addOrUpdateReactionCommentsCommentIdReactionsPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCountryQueryKey = (options?: Options<GetCountryData>) =>
  createQueryKey('getCountry', options);

/**
 * Get Country
 */
export const getCountryOptions = (options?: Options<GetCountryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCountryQueryKey(options),
  });
};

export const endpointHealthGetQueryKey = (
  options?: Options<EndpointHealthGetData>,
) => createQueryKey('endpointHealthGet', options);

/**
 * Endpoint
 */
export const endpointHealthGetOptions = (
  options?: Options<EndpointHealthGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await endpointHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: endpointHealthGetQueryKey(options),
  });
};
